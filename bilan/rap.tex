\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{textcomp}
\usepackage{fullpage}
\usepackage{algorithm2e}
\usepackage{caption}
\usepackage{color}
\usepackage{subcaption}
\usepackage{fancyvrb}
\fvset{commandchars=\\\{\}}
\usepackage[usenames,dvipsnames]{xcolor}
\frenchbsetup{ReduceListSpacing=false,CompactItemize=false}

\title{Recherches et réalisations relatives à une plateforme de
       collaboration estudiantine}
\author{Draft}

\begin{document}

\abovedisplayskip=1pt plus 0pt minus 0pt
\abovedisplayshortskip=6pt plus 3pt
\belowdisplayskip=9pt plus 3pt minus 9pt
\belowdisplayshortskip=9pt plus 3pt minus 4pt

\setlength{\voffset}{-20pt}

\begin{titlepage}
\begin{center}

\begin{minipage}{2in}
	\begin{flushleft}
		\textsf{\small{
		Faculté des Sciences\\
		Département d'Informatique}}
	\end{flushleft}
\end{minipage}
\begin{minipage}{4in}
	\begin{flushright}
		\includegraphics[scale=0.20]{imgs/ulb2.pdf}
	\end{flushright}
\end{minipage}

\vspace{120pt}

{\Large \bfseries Recherches et réalisations relatives à une plateforme de
       collaboration estudiantine}

\vspace{20pt}

\large{X \textsc{X}}

\vspace{90pt}

\includegraphics[scale=0.6]{imgs/ulb1.pdf}
\end{center}
\end{titlepage}

\setlength{\footskip}{40pt}

\abovedisplayskip=9pt plus 3pt minus 9pt
\abovedisplayshortskip=6pt plus 3pt
\belowdisplayskip=9pt plus 3pt minus 9pt
\belowdisplayshortskip=9pt plus 3pt minus 4pt
\setlength{\parskip}{0.5ex plus 0.2ex minus 0.2ex}
\setlength{\parindent}{0pt}

\newpage
\setlength{\voffset}{0pt}
\setcounter{tocdepth}{2}
\addcontentsline{toc}{subsection}{Table des matières}
\tableofcontents

\newpage

\section{Introduction}
\section{Historique, p402, fognar, beta402}
\section{Python, django, pourquoi + exemple de gros site}

\section{Architecture générale de Django}

Django est un \textit{framework} web dont le langage principal est Python et
dont l'architecture applique les principes de séparation des tâches, inspiré du
modèle MVC. Le but de ce logiciel est de permettre la conception rapide de site
en fournissant une série d'outils et de techniques au développeur. Par exemple,
Django rend transparent l'usage d'une base de donnée, standardise la manière
d'envoyer une page à l'utilisateur, fourni un système de session et d'authentification,
un système de gestion des logs intégrés...

La liste des fonctionnalités offertes par Django est assez longue, il est malheureusement
impossible d'être exhaustif dans le cadre de ce travail. Les plus importantes
ou celle spécifiquement employé par le projet seront détaillée dans les sections suivante.

Le protocole HTTP est un protocole sans état (\textit{stateless}), c'est à dire
que le client ou le serveur ne peuvent déterminer l'état de l'application client uniquement
sur base de la session HTTP. Cela implique qu'il est possible de traiter chaque requète HTTP
de manière individuelle, sans se soucier de celle qui avait avant ou après. Malheureusement,
pour la majorité des applications il faut aussi mettre en place un mécanisme permettant
d'identifier le client, de garder certaines propriétés de ce dernier...

Pour chaque requète d'une page web que le client fait au serveur, cette dernière
va arriver à Django au niveau du résolveur d'URL, première étape sur la figure XX.
Cette étape permet d'associer une fonction
à chaque demande du client. Les URLs sont reconnue au moyen d'expressions rationnelles.
Par exemple, si le développeur veut deux pages web différentes, l'une affichant
le résultat de la fonction \textit{page1} à l'adresse \texttt{http://host/path/index/} et
l'autre affichant le résultat de la fonction \textit{page2} à l'adresse
\texttt{http://host/path/page2/123/}, 123 étant un ID unique, il pourrait employer
le reconnaisseur d'URL suivant :

\begin{verbatim}
urlpatterns = patterns("",
    url(r"^path/index/$", page1),
    url(r"^path/page2/(\d)/$", page2),
)
\end{verbatim}

Le résolveur d'URL permet d'extraire certaines partie de l'URL reconnue et de les donnés
comme argument à la fonction à appeller. Dans l'exemple précédent, la fonction \textit{page2}
sera appelé avec le nombre en fin d'URL en argument.

Cette fonction est appellée la \textit{view}. Cette dernière prend au minimum un paramètre,
un objet requète. Il contient énormément d'information sur le client, l'url demandé,
la méthode HTTP employé, des paramètres du serveur... Le rôle de cette fonction
est de fabriquer la page web envoyé au client, c'est sa valeur de retour. Pour ce faire,
la fonction fait usuellement des requètes à la base de donnée en employant des modèles
d'objet et calcule le rendu de la page en employant le moteur de \textit{template}.

Par exemple, pour afficher l'index de l'exemple précédent, avec la fonction \textit{page1},
en souhaitant la bienvenue à l'utilisateur, le développeur pourrait employer le code
suivant~:

\begin{verbatim}
def page1(request):
    return render("index.html",
                  {"user": request.user.login})
\end{verbatim}

La fonction \textit{render} est un raccourci permettant d'appeller le moteur
de rendu de \textit{template}, de lui demander d'employer le fichier \texttt{index.html}
avec comme paramètre une variable \textit{user} dont la valeur est égale
au login de l'utilisateur.


template + schéma + class based generic view


\section{Interaction avec la base de donnée}

Un \textit{Object-relational mapping} (ORM) est une technique
pour convertire des objets en mémoire en enregistrement dans une base de donnée
relationnelle et inversément. Cette technique est très puissante et permet
au programmeur de ne plus interagir directement avec la base de donnée, juste
de manipuler des objets. A ce titre, Django possède un ORM, dont les principales
caractéristique vont être développée ici.

Comme évoqué dans la section précédente, la fonction \textit{view} a la responsabilité
du calcul de la page. Souvent cette dernière se base sur des informations présentes
en base de donnée. Chaque enregistrement de cette dernière, pour être exploitable
par Django, devra être assortie à un modèle, c'est à dire une \textit{class} Python
ayant une structure compréhensible par Django. Ce dernier créera le type dans la
base de donnée, y insérera les nouveaux éléments, supprimera ceux qu'il faut...

Par exemple, dans le cadre de l'application de collaboration, il faudra un objet
\textit{cours}. Ce dernier représentera un cours, aura un nom, une description,
un mnémonique (slug\footnote{https://en.wikipedia.org/wiki/Slug\_\%28publishing\%29}).
De plus, il sera possible de lier des documents et des fils de discussion à des
cours, d'où les relations \textit{manytomany} vers des objets de type Document
et Thread.

\begin{verbatim}
class Course(models.Model):
    slug = models.SlugField(unique=True)
    name = models.TextField()
    description = models.TextField(null=True)
    documents = models.ManyToManyField(Document)
    threads = models.ManyToManyField(Thread)
\end{verbatim}

L'ORM de Django permet de manipuler des objets cours grâce à une API simple.
Il est possible de créer des nouveaux objets en les instanciant, de les
sauver en base de donner, de lire ou modifier une valeur d'un champs,
de les supprimer, comme le monde l'exemple suivant :

\begin{verbatim}
>>> from application.models import Course
>>> c = Course(name="Informatique", slug="info-f-101", description="example")
>>> c
<Course: Informatique>
>>> c.save()
>>> c.name = "Informatique update"
>>> c.name
"Informatique update"
>>> c.save()
\end{verbatim}

\section{Synchronisation entre les différentes versions des modèles
         et la base de donnée}

Comme évoqué précédement, le code décrivant les
modèle est notament utilisé pour associer les champs des enregistrements
au propriété des objets. Cette technique permet de ne pas avoir
à s'occuper d'interagir avec la base de donnée et de s'occuper d'objet uniquement.
Malheureusement, au fil de l'évolution du projet, la structure des différents modèles
est amené à changer : il faut que la structure de la base de donnée évolue avec.
De cette constation découle plusieurs questions : comment, quoi, qui?

Ce travail conseil d'employer l'application \textit{django-south}
\footnote{http://south.aeracode.org/}. Cette dernière permet de garder l'état d'un modèle
à différent moment de son développement et à calculer des \textit{deltas} de modèle, équivalent
à un delta d'un code source dans un système de gestion de version. Ensuite,
à la demande de l'utilisateur, \textit{django-south} applique les \textit{deltas}
(appellé migrations) sur la base de donnée. Il possède des mécanismes pour les
appliquer dans l'ordre, ne pas les appliquer plusieurs fois, migrer les
données en même temps que le régleage de la table, possibilité de faire un rollback
sur une migration...

Physiquement, les migrations sont stockées dans des fichiers dans un sous dossier
\textit{migrations} de l'application django. Elle sont sous la forme de fichier
Python, pouvant être controler avec un système de gestion de version. Une explication
détaillée est disponible sur le site de \textit{djangopro}
\footnote{http://www.djangopro.com/2011/01/django-database-migration-tool-south-explained/}.

Par exemple, voici une session d'utilisation de l'outil \textit{django-south}.
Le scénario d'utilisation est le suivant : sur un ordinateur \texttt{(ve)}, le développeur
ajoute un nouveau modèle \textit{lapin} à l'application \textit{animal}. Ensuite,
il modifie ce modèle en ajoutant un champs. Par la suite, il copie les différents
fichiers sur une autre machines possédant déjà une base de donnée. Il convient de
modifier cette dernière pour être synchronisé avec les sources de l'application,
avec la commance \texttt{migrate}.

\begin{verbatim}
# Django app "animal", un seul modele : le Lapin, possédant un nom
(ve) $ cat animal/models.py
from django.db import models

class Lapin(models.Model):
    name = models.TextField()

# Initialisation du système Django-south
(ve) $ ./manage.py schemamigration animal --init
Creating migrations directory at '/home/hastake/mouh/mouh/animal/migrations'...
Creating __init__.py in '/home/hastake/mouh/mouh/animal/migrations'...
 + Added model animal.Lapin
Created 0001_initial.py.
You can now apply this migration with: ./manage.py migrate animal

# Application de la migration, contenant le nouveau modèle
(ve)hastake@phenyl ~/mouh/mouh $ ./manage.py migrate animal
Running migrations for animal:
 - Migrating forwards to 0001_initial.
 > animal:0001_initial
 - Loading initial data for animal.
Installed 0 object(s) from 0 fixture(s)

# Modification du modèle, ajout d'un champs, la race du lapin
(ve) $ cat animal/models.py
from django.db import models

class Lapin(models.Model):
    name = models.TextField()
    race = models.TextField(default="blanc")

# Création d'une nouvelle migration ajoutant la race du lapin, application
(ve) $ ./manage.py schemamigration animal --auto
 + Added field race on animal.Lapin
Created 0002_auto__add_field_lapin_race.py.
You can now apply this migration with: ./manage.py migrate animal
(ve) $ ./manage.py migrate animal
Running migrations for animal:
 - Migrating forwards to 0002_auto__add_field_lapin_race.
 > animal:0002_auto__add_field_lapin_race
 - Loading initial data for animal.
Installed 0 object(s) from 0 fixture(s)

# Sur une autre machine, après avoir mis à jour les sources
# de l'application (dont les migrations) : commande "migrate"
# exécute toutes les migrations manquantes
(ve remote) $ ./manage.py migrate
Running migrations for animal:
 - Migrating forwards to 0002_auto__add_field_lapin_race.
 > animal:0001_initial
 > animal:0002_auto__add_field_lapin_race
 - Loading initial data for animal.
Installed 0 object(s) from 0 fixture(s)

# Affichage des migrations : 
(ve) $ ls animal/migrations/
0001_initial.py
0002_auto__add_field_lapin_race.py
__init__.py
\end{verbatim}

A l'heure où ces lignes sont écrites, un nouveau système est déployé sur
les nouvelles version de Django : \textit{Schema alteration}
\footnote{http://www.kickstarter.com/projects/andrewgodwin/schema-migrations-for-django}
\footnote{https://github.com/django/django/pull/376}. Ce système permettra
une plus grande flexibilité, sera intégré à Django lui même, possèdera un
format de migration beaucoup plus lisible, plus facile à rebaser ou à
fusionner avec d'autres branches et détectera plus de modification de modèle
automatiquement.


\section{virtualenv, pip etc}

Outre Django, une application web a générale d'autres dépendances. Par exemple
ce travail dépend aussi de l'application \textit{django-south} détaillée plus haut.
Plus précisément, l'application web dépend de logiciel externe ayant certaine version.
Par exemple, un site fonctionnant sous Django 1.4 aura besoin de quelques modifications
pour fonctionner sous Django 1.5 et ne fonctionnera probablement pas du tout sous
Django 1.6. Pour éviter au développeur de s'arracher les cheveux, l'écosystème Python
fourni un outil nommé le \textit{virtualenv}.

Un environnement virtuel (\textit{virtualenv}) est une sandbox
\footnote{https://fr.wikipedia.org/wiki/Sandbox\_\%28s\%C3\%A9curit\%C3\%A9\_informatique\%29}
permettant d'installer toute une série de bibliothèque pour l'environnement
local sans perturber le système hote.

exemple d'usage

Pour distribuer et installer facilement une bibliothèque, l'écosystème Python
possède un logiciel nommé \textit{pip} + example, requirement.txt


\section{tour des fonctionalités du projet + screenshot}
\section{architecture du site genre differente app}
\section{comment configurer, creer le projet}

Un projet Django se configure via un fichier nommé \textit{settings.py},
présent dans le dossier racine. Ce fichier est au format Python et est principalement
une suite de définition de variables. Cette section cherche à détailler la majorité
de celle utile pour le projet.

\begin{description}
\item[Debug, Debug\_template] Ces variables, de type booléenne, permette d'activer
      ou d'inhiber l'affichage de commentaire et d'information lorsqu'une erreur
      intervient sur le site.
\item[Database] Cette variable stocke les informations sur la base de donnée. Elle
      permet de spécifier la bibliothèque à employer (sqlite3 pour le développement
      et postgresql\_psycopg2 pour la production), le nom de la base de donnée, l'utilisateur
      et le mot de passe à employer.
\item[Upload\_log] Variable contenant un chemin absolut vers l'endroit où logger
      les informations du gestionnaire d'upload de document.
\end{description}

\section{document parser, consumer pattern}

Une fonction utile pour le projet est de fournir aux étudiants la possibilité
de visionner un PDF directement dans l'interface web au lieu de les obliger
à le télécharger. Cette fonction est similaire à la visionneuse de document fournie
par Google Doc. Pour offrir ce service, il est impossible de calculer le rendu du PDF
à chaque fois que l'étudiant charge la visionneuse, il faut 


\section{fonction recherche}

Actuellement, le projet héberge plusieurs centaines de document.
Afin de permettre à l'utilisateur de trouver un document particulier, une
fonction de recherche fut implémentée. Tout d'abord, cette section abordera
la question de précalcul sur les documents présent, ce qui est exécuté lors
du traitement d'un document lors de son upload. Ensuite, cette section
détaillera la fonction de calcul du classement des documents en fonction
d'une certaine requète.

Le traitement des documents évoqués à la section précédente inclue une extraction
textuel. Au moyen de la bibliothèque \textit{poppler}, il transforme un document
PDF en une représentation textuelle. Ensuite il extrait les mots de cette représentation
puis leur racine morphologique grâce à un processus appelé \textit{stemming}
\footnote{https://en.wikipedia.org/wiki/Stemming}. Enfin, pour tout document,
il compte le nombre d'occurence de chaque racine ainsi que le nombre total de mot du document.
Il sauvegarde le tout dans une base de donnée (le tuple : document, racine, nombre).

Le \textit{term frequency–inverse document frequency} (TF-IDF) est un indicateur
qui reflete l'importance d'un mot dans un document par rapport à son importance
dans l'ensemble du corpus de document. Il est proportionnel à la fréquence d'un terme
d'un document par rapport à la fréquence de ce terme dans l'ensemble des documents.
Par exemple, le verbe "est" est très fréquent dans tout les documents, il aura
un très faible TF-IDF, probablement constant pour tout les documents,
alors que le nom "sécurité" aura un TF-IDF beaucoup plus élevé dans un document
relatif à la sécurité informatique (parce que le terme sera souvent employé)
par rapport à un document sur les mathématiques discretes (où il ne sera probablement
pas présent). Cet indicateur est la première manière utilisé pour classer
un document par rapport à un autre étant donné une requète de recherche.

Ensuite, il est intuitif de ce dire que les documents souvent visité sont
plus important. Le classement brute fourni par le calcul du TF-IDF est donc raffiné
par rapport aux nombres de vue et téléchargement des documents.


\section{auth}
\section{sécurité, CSRF, XSS, injection...}

D'une manière générale, les notions de sécurité sont importantes en informatique
et le domaine du web ne fait pas exception. Une fois déployé en production,
un site web est suseptible de ce faire attaquer par n'importe qui, il est donc
important de passer en revue les vulnérabilités les plus populaires et de les prévenir.

Tout d'abord, un premier type de vulnérabilité sont les SQL Injection. Cette attaque
consiste à déformer une requète SQL hors de son but premier dans le but de détourner
le résultat de cette requète. Généralement, les requètes contiennent le contenu
de variable, parfois venant d'entrée utilisateur et ce dernier peut essayer
de faire "déborder" ces variables pour transformer la sémantique de la requète. Par
exemple, si un algorithme d'authentification cherche à vérifier que l'utilisateur existe
et possède le bon mot de passe, il pourrait exécuter la requète si dessous.
Un utilisateur malveillant pourrait entrer une autre valeur et si l'algorithme
vérifie le résultat de retour (0 pour l'utilisateur unexistant, 1 pour l'utilisateur
existant), l'attaquant pourra se logger.

\begin{Verbatim}
SELECT count(*) FROM users
  WHERE username = "lama" and password = "secret";

SELECT count(*) FROM users
  WHERE username = "\textcolor{Blue}{lama" or 1 = 1 LIMIT 1;#}" and password = "";
\end{Verbatim}

Avec le framework Django, l'ORM est protégé contre les injections SQL à plusieurs
niveau. D'une part, les valeurs entrées dans les formulaires sont nettoyées avant
d'être employée dans les fonctions \textit{views} et l'ORM possède un mécanisme
de sécurité contre tout type d'injection connue.

Ensuite, un autre type d'attaque très populaire est le \textit{cross-site scripting} (XSS).
Il s'agit d'insérer dans une page un script malicieux, généralement dans du contenu
produit par l'utilisateur (commentaire sur un forum, nom d'utilisateur sur une page de profile...)
qui va s'exécuter dans le navigateur des autres clients, pouvant voler des informations.

Pour se protéger de cette attaque, Django nettoye les formulaires des entrées utilisateurs
comme évoqué précédement, ensuite il empeche du contenu de script ou HTML d'être directement
rendu dans la page web au niveau du moteur de \textit{template}. Par exemple,
si le développeur veut afficher le text d'un commentaire, le template pourrait contenir
\texttt{\{\{ comment \}\}}. Si la variable \textit{comment} contient du HTML,
il sera transformé en texte, sans pouvoir être interpreté par le navigateur du client.

Enfin, une attaque courante est le concept de \textit{cross site request forgery} (CSRF).
Cet une attaque un peu plus évoluée que les deux précédentes, impliquant la fabrication
d'une requète HTTP vers le site 


\section{css/html testing}
\section{django testing}
\section{github push hook et continuous testing}

Un contrôle de révision de source est un système permettant de garder un historique
de toutes les versions du code source d'un projet. Il permet de partager les ressources
entre différent développeur, développer les fonctionnalités isolées entre elle sous
forme de branche, exécuter plusieurs versions du logiciel... Un système de révision
de source distribué est un système de révision sans serveur central. Chaque
utilisateur de ce système possède l'entiereté de l'historique et des informations,
il n'y a pas de source d'authorité sur le code source.

Ce projet a été développer sous Git, un système de révision de source utilisé notament
pour le kernel Linux. Il est très puissant et très populaire. Afin de publier le code
source, le site Github fut employé.

\section{conclusion}

\end{document}
